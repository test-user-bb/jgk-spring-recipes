#summary JPA
= Introduction =

 * JPA = Java Persistence API
== Annotations ==
 * @Entity
 * @OneToOne
 * @ManyToOne
 * @ManyToMany(mappedBy = "employees")
 * @Transient
 * @MappedSuperclass
 * @AttributeOverride
 * @AssociationOverride
 * @JoinColumn(name="ADDR_ID")
 * @Table(name="FT_EMP")
 * @DiscriminatorValue("FT")
 * @PrimaryKeyJoinColumn(name="FT_EMPID")
 * @Id
== Collections supported ==
 * Collection
 * List
 * Set
 * Map
== Libraries/Dependencies ==
 * javax.persistence.Entity  org.hibernate:hibernate-jpa-2.0-api:3.5.6-Final
== Good to know ==
 * A mapped superclass, unlike an entity, is not queryable and cannot be passed as an argument to EntityManager or Query operations. A mapped superclass cannot be the target of a persistent relationship.
 * An entity may inherit from another entity class. Entities support inheritance, polymorphic associations,
and polymorphic queries.
 * Both abstract and concrete classes can be entities. Both abstract and concrete classes can be annotated
with the Entity annotation, mapped as entities, and queried for as entities.
 * Entities can extend non-entity classes and non-entity classes can extend entity classes.
 * Runtime exceptions thrown by property accessor methods cause the current transaction to be rolled
back.
 * An instance becomes persistent by means of the EntityManager API.
 * Composite primary keys typically arise when mapping from legacy databases when the
database key is comprised of several columns. The EmbeddedId and IdClass annotations are used
to denote composite primary keys.
 * The primary key class must define equals and hashCode methods. The semantics of value
equality for these methods must be consistent with the database equality for the database types
to which the key is mapped.
 * Embeddable classes are not annotated as Entity. Embeddable classes must be annotated as
Embeddable or denoted in the XML descriptor as such.
 * Relationships among entities may be one-to-one, one-to-many, many-to-one, or many-to-many. Relationships
are polymorphic.
 * Relationships may be bidirectional or unidirectional. A bidirectional relationship has both an owning
side and an inverse side. A unidirectional relationship has only an owning side. The owning side of a
relationship determines the updates to the relationship in the database.
 * In ManyToMany there is a join table that is named A_B (owner name first).
=== Rules for bidirectional relationships ===
 * The following rules apply to bidirectional relationships:
  * The inverse side of a bidirectional relationship must refer to its owning side by use of the
mappedBy element of the OneToOne, OneToMany, or ManyToMany annotation. The
mappedBy element designates the property or field in the entity that is the owner of the relationship.
   * The many side of one-to-many / many-to-one bidirectional relationships must be the owning
side, hence the mappedBy element cannot be specified on the ManyToOne annotation.
   * For one-to-one bidirectional relationships, the owning side corresponds to the side that contains
the corresponding foreign key.
   * For many-to-many bidirectional relationships either side may be the owning side.
== Resources ==
 * [http://jcp.org/aboutJava/communityprocess/final/jsr220/ JPA Spec - jsr-220]
 * [http://www.oracle.com/technetwork/java/javaee/downloads/index.html JPA Reference Implementation]
 * [http://en.wikipedia.org/wiki/Java_Persistence_API Wikipedia]