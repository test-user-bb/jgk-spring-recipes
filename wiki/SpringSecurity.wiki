#summary spring security
 * What type of [http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/index.html?org/springframework/security/core/Authentication.html UserDetailsService] implementations exist?
  * CachingUserDetailsService
  * [http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/index.html?org/springframework/security/core/Authentication.html InMemoryDaoImpl] - Retrieves user details from an in-memory list created in the application context. Username lookups are case-insensitive.
  * [http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/index.html?org/springframework/security/core/Authentication.html JdbcDaoImpl] - uses jdbc to get info from database, specifies tables (Users, Authorities) and columns
  * [http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/index.html?org/springframework/security/core/Authentication.html JdbcUserDetailsManager] - CRUD interface to JdbcDaoImpl
  * LdapUserDetailsManager
  * LdapUserDetailsService
  * UserDetailsServiceWrapper
 * How do you get information about the currently authenticated user?
{{{
Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
if (principal instanceof UserDetails) {
   String username = ((UserDetails)principal).getUsername();
} else {
   String username = principal.toString();
}
}}}
 * [http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/context/SecurityContextHolder.html SecurityContextHolder]
 * [http://static.springsource.org/spring-security/site/faq.html FAQ]
 * Spring Security Basics (3 steps)
  # add spring security jars to your classpath 
  # Add *DelegatingFilterProxy* to your web.xml
  # create basic security configuration xml file:
{{{
    <global-method-security/> (recommended)
    <http auto-config="true"/> (recommended)
    <intercept-url .../> (one or more)
    <*-details-service> (e.g. LDAP, DB, XML, custom)
}}}
 * Spring EL Annotations (4 annotations)
  * @PreAuthorize
  * @PostAuthorize
  * @PreFilter
  * @PostFilter
 * Spring EL Expressions:
  * hasRole(String)
  * hasAnyRole(String)
  * hasPermission(String)
  * isAnonymous
  * isRememberMe
  * isFullyAuthenticated
  * authentication
  * permitAll
  * denyAll
  * access to the arguments and return object
 * Examples of Spring EL Annotations:
{{{
...add the following to your security configuration xml file:
<security:global-method-security expression-annotations="enabled"/>
...
  public interface MyBean {
     @PreAuthorize("hasRole('ROLE_SUPERVISOR') or (hasRole('ROLE_TELLER') and (#account.balance + #account >= -#account.overdraft))")
     void post(Account account, float amount);
  }
  
}}}
 * AspectJ 
{{{
<security:global-method-security>
  <security:protect-pointcut access="ROLE_USER" expression="execution(* *.get*(..))"/>
  <security:protect-pointcut access="ROLE_ADMIN" expression="execution(* *.set*(..))"/>
</security:global-method-security>

}}}
 * You can apply method-level security directly in a bean configuration:
{{{
<bean id="jed" class="com.jgk.springrecipes.stuff.BigStuff">
   <security:intercept-methods>
     <security:protect access="ROLE_ADMIN" method="set*"/>
     <security:protect access="ROLE_USER" method="get*"/>
   </security:intercept-methods>
</bean>
}}}
 * [http://java.sun.com/developer/technicalArticles/J2EE/security_annotation/ Security Annotations]: 
{{{
javax.annotation.security.PermitAll
javax.annotation.security.DenyAll
javax.annotation.security.RolesAllowed
javax.annotation.security.DeclareRoles
javax.annotation.security.RunAs
}}}
 * Spring's @Secured
  *  _Note: JSR250 security annotations are the standard, so should be preferred over Spring @Secured_
  * Useful since it can be applied to Interfaces AND classes, whereas the JSR250 security annotations may only be applied to classes.
 * How do you enable JSR250 security?
{{{
  <security:global-method-security jsr250-annotations="enabled">
}}}
 * global-method-security
{{{
<security:global-method-security />
global-method-security
Provides method security for all beans registered in 
 the Spring application context. Specifically, beans will 
 be scanned for matches with the ordered list of 
 "protect-pointcut" sub-elements, Spring Security 
 annotations and/or. Where there is a match, the 
 beans will automatically be proxied and security 
 authorization applied to the methods accordingly. If 
 you use and enable all four sources of method 
 security metadata (ie "protect-pointcut" declarations, 
 expression annotations, @Secured and also JSR250 
 security annotations), the metadata sources will be 
 queried in that order. In practical terms, this enables 
 you to use XML to override method security metadata 
 expressed in annotations. If using annotations, the 
 order of precedence is EL-based (@PreAuthorize etc.), 
 @Secured and finally JSR-250.
}}}
 * Official Java EE and Java 6 way of doing method security:
{{{
  @DenyAll
  @RolesAllowed("ROLE_USER")
}}}
 * Method Authorization
  * Web authorization relies on pattern matching
  * No pattern match means no authorization
  * Client/UI technology agnostic
  * Flexible - esp. with Expression Language
 * Better to move this protection to .xml configuration so you do not need to have this similar code in many different places.
  * So in a configuration file (e.g. security-config.xml) you might include:
{{{
   <security:http auto-config="true">
       <security:intercept-url pattern="/special_user_page.jsp" access="ROLE_SPECIAL_USER"/>
   </security:http>
}}}
 * In a special_user_page.jsp file you can check user in role and throw a spring exception:
  {{{
     <% 
         if (!request.isUserInRole("ROLE_SPECIAL_USER")) {
             throw new AccessDeniedException("You must be a SPECIAL_USER to use this feature.");
         }
     %>
  }}}
 * How to check if user is actually part of a role?
  {{{ request.isUserInRole("ROLE_USER"); }}}
 * Authorization with Spring Security:
  * web authorization
  * method authorization
 * Basic Authentication uses Base64 encoding.  Very simple and not-secure data.  So, best to use over a secure channel (https).
 * Basic Authentication is integrated with Spring's  [http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/remoting/httpinvoker/SimpleHttpInvokerRequestExecutor.html org.springframework.remoting.httpinvoker.Authentication.SimpleHttpInvokerRequestExecutor].
 * Basic Authentication uses HTTP header:
{{{
   Name: "Authorization"
   Value: "Basic" + " " + Base64(username + ":" + password)
}}}
 * Minimum Maven dependencies:
  * org.springframework.security:spring-security-core:3.0.5.RELEASE
  * org.springframework.security:spring-security-config:3.0.5.RELEASE
  * org.springframework.security:spring-security-web:3.0.5.RELEASE
  * org.springframework:spring-web:3.0.5.RELEASE
{{{
  	<dependency>
  		<groupId>org.springframework.security</groupId>
  		<artifactId>spring-security-core</artifactId>
  		<version>3.0.5.RELEASE</version>
  		<type>jar</type>
  		<scope>compile</scope>
  	</dependency>
  	<dependency>
  		<groupId>org.springframework.security</groupId>
  		<artifactId>spring-security-config</artifactId>
  		<version>3.0.5.RELEASE</version>
  		<type>jar</type>
  		<scope>compile</scope>
  	</dependency>
  	<dependency>
  		<groupId>org.springframework.security</groupId>
  		<artifactId>spring-security-web</artifactId>
  		<version>3.0.5.RELEASE</version>
  		<type>jar</type>
  		<scope>compile</scope>
  	</dependency>
  	<dependency>
  		<groupId>org.springframework</groupId>
  		<artifactId>spring-web</artifactId>
  		<version>3.0.5.RELEASE</version>
  		<type>jar</type>
  		<scope>compile</scope>
  	</dependency>

}}}
 * Default settings:
  * Login page: {{{ /spring_security_login }}}
  * Failure page: {{{ /spring_security_login?login_error }}}
  * Posts to: {{{ /j_spring_security_check }}}
 * Spring Security will auto-render a login page if you do not specify a custom login page URL.
 * Authentication Mechanisms vs. Authentication Providers
  * Mechanism bundles user info (e.g. username/password or cookie) into an AuthenticationRequest which is passed to the providers. Provider examines request to determine if sufficient information available to authenticate user.  If 'yes', then returns an AuthenticationResponse (has user roles, their format?, extra profile info) to the Mechanism (the mechanism stores it on on the [http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/context/SecurityContextHolder.html SecurityContextHolder]).
 * Run samples:
{{{
 You can also run the sample web applications directly using gradle's Jetty plugin. For example, to run the contacts sample

 $ cd samples/contacts
 $ gradle jettyRun

which will start the server on port 8080. You can then access it using the URL http://localhost:8080/contacts.
}}}
 * Source code available via git:
{{{
git clone git://git.springsource.org/spring-security/spring-security.git
}}}
 * Build source with [http://gradle.org Gradle]
{{{
 $ cd spring-security
 $ ./gradlew build
}}}
 * in application configuration:
{{{
<authentication-manager>
<authentication-provider>
<user-service>
<user name="jimi" password="jimispassword" authorities="ROLE_USER, ROLE_ADMIN" />
<user name="bob" password="bobspassword" authorities="ROLE_USER" />
</user-service>
</authentication-provider>
</authentication-manager>
}}}
 * web.xml
{{{
<filter>
<filter-name>springSecurityFilterChain</filter-name>
<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
<filter-name>springSecurityFilterChain</filter-name>
<url-pattern>/*</url-pattern>
</filter-mapping>
}}}
 * Security
{{{
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:security="http://www.springframework.org/schema/security"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/security
http://www.springframework.org/schema/security/spring-security-3.0.xsd">
...
</beans>
}}}
 * Or:
{{{
<beans:beans xmlns="http://www.springframework.org/schema/security"
xmlns:beans="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/security
http://www.springframework.org/schema/security/spring-security-3.0.xsd">
...
</beans:beans>
}}}
 * [http://www.springsource.com/products/sts SpringSource Tool Suite ]
 * NOTE: elements here lifted from Ben Alex's book on spring security.
 * [http://apr.apache.org/versioning.html Apache Portable Runtime Project versioning guidelines] _MAJOR.MINOR.PATCH_
  * Versions are denoted using a standard triplet of integers: MAJOR.MINOR.PATCH. 
  * The basic intent is that MAJOR versions are incompatible, large-scale upgrades of the API. 
  * MINOR versions retain source and binary compatibility with older minor versions, and changes in the PATCH level are perfectly compatible, forwards and backwards.
 * 2007 - Acegi Security is rebranded as *Spring Security*
 * Three main areas of interest in respect of authorization:
  # authorizing web requests
  # authorizing whether methods can be invoked
  # authorizing access to individual domain object instances
 * [http://jcaptcha.sourceforge.net/ JCaptcha] integration for human user detection
 * Spring Security currently supports authentication integration with:
  * HTTP BASIC authentication headers (an IEFT RFC-based standard)
  * HTTP Digest authentication headers (an IEFT RFC-based standard)
  * HTTP X.509 client certificate exchange (an IEFT RFC-based standard)
  * LDAP
  * Form-based authentication (for simple user interface needs)
  * OpenID authentication
  * Authentication based on pre-established request headers (such as Computer Associates Siteminder)
  * JA-SIG Central Authentication Service (otherwise known as CAS, which is a popular open source single sign on system)
  * Transparent authentication context propagation for Remote Method Invocation (RMI) and HttpInvoker (a Spring remoting protocol)
  * Automatic "remember-me" authentication (so you can tick a box to avoid re-authentication for a
predetermined period of time)
  * Anonymous authentication (allowing every call to automatically assume a particular security identity)
  * Run-as authentication (which is useful if one call should proceed with a different security identity)
  * Java Authentication and Authorization Service (JAAS)
  * JEE container autentication (so you can still use Container Managed Authentication if desired)
  * Kerberos
  * Third Party Providers
   * Java Open Source Single Sign On (JOSSO), AppFuse, AndroMDA, Mule ESB, Direct Web Request (DWR), Grails,  Tapestry, JTrac, Jasypt, Roller, Elastic Path, Atlassian Crowd
 * *Authorization* refers to the process of deciding whether a principal is allowed to perform an action within your application.
 * *Authentication* is the process of establishing a principal is who they claim to be (a “principal” generally means a user, device or some other system which can perform an action in your application).
 * [http://s3.amazonaws.com/dist.springframework.org/release/SEC/spring-security-3.0.5.RELEASE.zip Download Spring Security 3.0.5.RELEASE]
 * Spring Security works with webapps, but also with:
  * Batch jobs
  * Rich clients
  * Integration tests
 * [http://www.viddler.com/explore/oredev/videos/22/ Flash Video - Ben Alex of SpringSource (has Swedish Fiance)] - ben.alex@springsource.com
 * Spring Security used to be Acegi Security - became Spring Security in 2008
 * Spring Security capabilities:
  * Authentication
  * Web URL authorization
  * Method invocation authorization
  * Channel security
  * Human user detection
  * Domain instance based security (ACLs - Access Control Lists - e.g. can only see specific domain patient information)
  * WS-Security (via Spring Web Services)
  * Flow Authorization (via Spring Web Flow)
 * What Spring Security *IS NOT*:
  * [http://en.wikipedia.org/wiki/Firewall_(computing) Firewall]
  * [http://en.wikipedia.org/wiki/Proxy_server Proxy Server]
  * [http://en.wikipedia.org/wiki/Intrusion_detection_system IDS]
  * Operating System Security
  * JVM (sandbox) Security