#summary Remoting

 * [http://static.springsource.org/spring/docs/2.5.x/reference/remoting.html Spring Remoting]

=== Goals of Spring Remoting ===
 * Hide 'plumbing' code
 * Configure and expose services *declaratively*
 * Support multiple protocols in a consistent way

=== Advantages: Spring Remoting vs. RMI ===
==== Problems with traditional remoting and RMI ====
 * Big Picture: _Remoting mechanisms provide an abstraction over transport details._
 * Abstractions are 'leaky', meaning the code must conform to a particular model.
 * RMI:
  * {{{Service}}} interface extends *{{{Remote}}}*
  * {{{Service}}} client extends *{{{UnicasterRemoteObject}}}*
  * {{{Client}}} must catch *{{{RemoteException}}}s*
  * *Violates a separation of concerns*
  * *Couples business logic to remoting infrastructure*

=== Spring Remoting:  Declarative Approach ===
 * Spring's abstraction uses a configuration-based approach
 * Server side:
  * Expose existing services with *NO* code changes!
 * Client side:
  * Invoke remote methods from existing code
  * Take advantage of polymorphism by using dependency injection
=== Spring Remoting: Consistency across protocols ===
 * Spring's exporters and proxy {{{FactoryBean}}}s bring consistent approach to multiple protocols:
  * provides flexibility
  * promotes ease of adoption
 * Server Side
  * expose a single service over multiple protocols
 * Client Side
  * switch easily between protocols
  * migrate between remote vs. local deployments

=== Goal/Cfg of RMI Service Exporter ===
 * Spring provides *exporters* to handle server-side requirements:
  * binding to registry or exposing an endpoint
  * conforming to a programming model if needed
 * Spring provides {{{FactoryBean}}}s that generate *proxies* to handle client-side requirements
  * Communicate with server-side endpoint
  * convert remote exceptions to a runtime hierarchy

=== Goal/Cfg of RMI Proxy Generator ===

=== Difference between RMI Service Exporter and {{{HttpInvoker}}} ===
=== {{{HttpInvoker}}} ===
 * Spring's HTTP invoker. Spring provides a special remoting strategy which allows for Java serialization via HTTP, supporting any Java interface (just like the RMI invoker). The corresponding support classes are {{{HttpInvokerProxyFactoryBean}}} and {{{HttpInvokerServiceExporter}}}.
=== {{{HttpInvoker}}} Questions ===
 * Does {{{HttpInvoker}}} require running on a web server on the client side?
 * Does {{{HttpInvoker}}} require running on a web server on the server side?